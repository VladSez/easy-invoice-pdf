---
description:
globs:
alwaysApply: true
---

Project Structure and Architecture Guidelines

Directory Structure:

```
â”œâ”€â”€ app/                    # Next.js App Router directory
â”‚   â”œâ”€â”€ (auth)/            # Auth-related routes (grouped)
â”‚   â”œâ”€â”€ api/               # API routes
â”‚   â””â”€â”€ layout.tsx         # Root layout
â”œâ”€â”€ components/            # Reusable components
â”‚   â”œâ”€â”€ ui/               # Shadcn UI components
â”‚   â””â”€â”€ [feature]/        # Feature-specific components
â”œâ”€â”€ lib/                   # Shared utilities
â”‚   â”œâ”€â”€ utils.ts          # General utilities
â”‚   â””â”€â”€ validations.ts    # Zod schemas
â”œâ”€â”€ hooks/                # Custom React hooks
â”œâ”€â”€ styles/               # Global styles
â””â”€â”€ types/                # TypeScript types
```

Component Organization:

- Group related components in feature directories
- Keep components small and focused
- Extract reusable logic into custom hooks
- Place shared types in dedicated files

File Naming:

- Use kebab-case for directories and files
- Components: PascalCase.tsx
- Utilities: camelCase.ts
- Types: PascalCase.types.ts

Component Structure:

```typescript
// types.ts
interface Props {
  // ... props interface
}

// helpers.ts
function helperFunction() {
  // ... helper logic
}

// Component.tsx
import { type Props } from "./types";
import { helperFunction } from "./helpers";

export function Component({ prop1, prop2 }: Props) {
  // ... component logic
}
```

Data Fetching:

- Use Server Components for data fetching
- Implement proper caching strategies
- Handle loading and error states
- Use React Suspense boundaries

Route Organization:

- Group related routes in directories
- Use route groups (parentheses) for organization
- Keep page components lean
- Extract business logic to separate files

State Management:

- Use Server Components when possible
- Keep client state minimal
- Use React Context sparingly

API Structure:

- Organize by feature/resource
- Use consistent error handling
- Implement proper validation
- Follow RESTful conventions

Red flags in a React codebase

ðŸš© functions like <button onClick={handleClick}

- handleClick doesn't explain what it does
- you lose colocation
- need new names for each callback

Inline callbacks can call multiple functions with good names

onClick={() => {
analytics.event('this-button')
openModal()

ðŸš© useMemo

React devs are terrified of renders and often overuseMemo

- memoize things that you pass as props to components that may have expensive children
- it's ok for leaf components to over-render

useMemo does not fix bugs, it just makes them happen less often

ðŸš© <div onClick

divs are not interactive elements and adding onClick requires implementing keyboard control, screen reader announcement, etc

This is almost never the right move, and anyone capable of doing it right (the new tweet button) isn't going to be swayed by this tweet
